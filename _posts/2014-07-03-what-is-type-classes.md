---
layout: post
title:  "型クラスってなんだろう"
date:   2014-07-03 19:35:00
categories: [Java,Scala,Haskell]
---

[猫型さんのブログ記事1](http://nekogata.hatenablog.com/entry/2014/06/30/062342), [2](http://nekogata.hatenablog.com/entry/2014/07/01/184246)を読んで「なるほどなあ」と思ったものの、なんかぼんやりと自分でも思うところがあるので少しつぶやいてたら自分のまとめを書きたくなったので書いてみます。

## 型クラスと型クラスのインスタンス

僕の中で「型クラス」ってワードが出てきたのがHaskellを勉強している時のこと。

型(type)と言うのは、あるまとまったデータの構造と種類に名前を付けるものです。
オブジェクト指向の「クラス(class)」などと比較されるものですが、ここでは「データ構造と種類」のみを表すことにします。

その型(データ型)がどのような側面を持っているか、というものを規定するときに型クラス(type class)を定義します。Haskellだと例えば次のようになります。

- `Eq` : 2つの値が等しいか判定できる。
- `Ord`: 2つの値の大小を比較できる。
- `Functor` : ファンクタ則を持つコンテナ型のデータ構造
- `Monad` : モナド則を持つコンテナ型のデータ構造

 `instance Eq Integer` と宣言することで、 `Integer` は「 `Eq` 型クラスのインスタンス」と宣言することが出来ます。

型クラスにも階層構造があり、例えば `Ord` 型クラスは `Eq` 型クラスのサブクラスです。

## (デフォルト実装付き)インターフェースとしての型クラス

先ほどの型クラスは基本的に「ある関数が全ての型クラスのインスタンスに定義されている」という意味を持つので、Javaなどのインターフェース(interface)とみなすことが出来ます。

先ほどインスタンスとして宣言することができる、と書きましたが、インスタンス化するには実装を補う必要があるので、型クラスのインスタンス定義では必要な関数に対する実装を行います。

例えば、 `Eq` の例では `==` という関数は実装されていませんが、 `/=`(not equal, ≠)は「 `==` の否定」と定義されていますので、実装は必要ありません（というか出来ません）。

`Eq` の例を出すとJavaでは`Object#equals`, Scalaでは `==` が具体的な実装のように見えますが、結構違うものです。

Javaでは最上位クラスのObjectに簡易な実装が定義されており、具象クラスでそれぞれ再実装することになっていますが、どのクラスが `equals` を正しく再実装したかどうかわからないので安易に使うことが出来ず混乱の元になります。

### Scalaで実装例

では、Scalaで改めて`Eq`を`Int`に対して定義してみましょう。（注:これは通常の`==`よりかなり貧弱です）

```scala
trait Eq[T] {
  def eql(other: Any): Boolean
}

implicit class IntEq(i: Int) extends Eq[Int] {
  def eql(other: Any) = other match {
    case j: Int => i == j
    case _ => false
  }
}

1 eql 1 //=> true
1 eql "1" //=> false
```

これでIntを拡張出来ました。他のクラスも同様に実装すればよいです。

```scala
implicit class StringEq(s: String) extends Eq[String] {
  def eql(other: Any) = other match {
    case t: String => s == t
    case _ => false
  }
}
```

### 後付のインターフェースと実装

Javaでは通常インターフェースが先に定義されており、そのインターフェースを満たす具象クラスを記述しますが、型クラスの場合は既存の具象クラスに対して新たなインターフェースを追加した形になります。

インターフェースと見なせるなら、これをコンポーネントとして利用する関数などの具体的な実装があって構わないはずです。Scalaではそれを作ることも出来ます。

```scala
def isSame[T <% Eq[_]](a: T, b: T) = a eql b
```

この関数で`T <% Eq[_]`とは `Eq[_]` の型クラスのインスタンスであることを条件にしていて、型クラスを実装していなければ、コンパイル時にエラーとなります。

実際にはシンタックスシュガーで、以下の様な関数の型が表示されます。

```
isSame: [T](a: T, b: T)(implicit evidence$1: T => Eq[_])Boolean
```

ここで implicit parameter(evidence)として、このような関数の存在が暗黙的に定義されていることを要求しています。

つまり具体的にはこうなります。

```scala
def isSame[T](a: T, b: T)(implicit ev: T => Eq[_]) = ev(a).eql(b)
```

## 参照透明な構造の宣言としての型クラス

もう一つ、忘れてはいけないのが関数型として参照透明であることです。

関数にxを入力したら、必ずyが返るように定義すべきです。

Haskellでは、実装者依存とはいえ、ある法則は常に満たすべきであるとも宣言しています。

例えば `Eq` では以下を満たすべきです。

- `assertTrue(a == a)` : 同じ値なら常に `true`
- `if ((a == b) == true && (b == c) == true) { assertTrue(a == c) }`
